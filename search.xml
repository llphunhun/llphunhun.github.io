<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F24%2Fmybatis%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[my blog]]></title>
    <url>%2F2019%2F04%2F01%2Fmy-blog%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mybatis简单工作流程]]></title>
    <url>%2F2019%2F03%2F26%2F%5Bobject%20Object%5D%2F</url>
    <content type="text"><![CDATA[Mybatis简单工作流程SqlSessionFactory​ SqlSessionFactory是MyBatis的关键对象,它是个单个数据库映射关系经过编译后的内存镜像。 ​ 每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。同时SqlSessionFactory也是线程安全的,SqlSessionFactory一旦被创建,应该在应用执行期间都存在.在应用运行期间不要重复创建多次,建议使用单例模式.SqlSessionFactory是创建SqlSession的工厂。 SqlSession​ SqlSession是MyBatis的关键对象,是执行持久化操作的独享,类似于JDBC中的Connection。它是应用程序与持久层之间执行交互操作的一个单线程对象,也是MyBatis执行持久化操作的关键对象。它的底层封装了JDBC连接,可以用SqlSession实例来直接执行被映射的SQL语句。每个线程都应该有它自己的SqlSession实例.SqlSession的实例不能被共享，同时SqlSession也是线程不安全的，绝对不能讲SqlSeesion实例的引用放在一个类的静态字段甚至是实例字段中。也绝不能将SqlSession实例的引用放在任何类型的管理范围中,比如Servlet当中的HttpSession对象中。使用完SqlSeesion之后关闭Session很重要,应该确保使用finally块来关闭它。 操作方式​ 核心虽然是 SqlSessionFactory但是我们真正要操作的是SqlSession。我们一般将产生SqlSession实例的过程封装在一个工具包（util）当中。这里我的类名是MybatisUtil： 123456789101112131415161718192021222324252627282930313233343536package com.llp.util;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MybatisUtil &#123; private static SqlSessionFactory sqlSessionFactory; static&#123;//通过静态代码块初始化静态变量SqlSessionFactory String resource = "mybatis.cfg.xml"; InputStream in = null ; try&#123; in = Resources.getResourceAsStream(resource);//获取文件资源信息 sqlSessionFactory = new SqlSessionFactoryBuilder().build(in);//获得 SqlSessionFactory对象 &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if(in != null) &#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static SqlSession getSession() &#123;//其他包中调用该工具包构造SqlSession需要执行的方法 return sqlSessionFactory.openSession(); &#125;&#125; ​ 然后我们只需要调用MybatisUtil的getSession()方法即可。 特别强调的是SqlSession是单线程非安全的，所以只能每次打开之后都要关闭，并且每一次会话之后都要关闭（close）。]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring简单入门操作]]></title>
    <url>%2F2019%2F03%2F26%2F%5Bobject%20Object%5D%2F</url>
    <content type="text"><![CDATA[Spring简单入门操作简介​ 一个web框架，讨论java企业级开发问题。EJB，过于繁琐，要继承类，实现多个多个接口，写多种方法。 ​ 为了简化开发工作，构建最早的Spring。获取对象的方式发生极大的改变。 ​ 传统java获取对象的方式： 123//传统java获取对象的方式：明显的是这是写死的方式。Girl g = new Girl(); ​ Spring作者追求的是轻量级，并且是容器型。即大本分对象应该从容器当中获取，而不是进行Java硬编码。容器：所需要的对象应该是由这个容器提供。 ​ 官网：https://spring.io/ 基础技术 java 反射 xml xml解析技术 代理 大量的设计模式 基础环境搭建 添加Spring依赖。 编写一个Spring的配置文件。 通过Spring上下文对象，获取获取对象。 Spring可以学习的模块： Core technologies: dependency injection, events, resources, i18n, validation, data binding, type conversion, SpEL, AOP. Testing: mock objects, TestContext framework, Spring MVC Test, WebTestClient. Data Access: transactions, DAO support, JDBC, ORM, Marshalling XML. Spring MVC and Spring WebFlux web frameworks. Integration: remoting, JMS, JCA, JMX, email, tasks, scheduling, cache. Languages: Kotlin, Groovy, dynamic languages. 相对于5的官方文档，Spring4的官方文档更加易懂：https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/ 5的官方文档：https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/core.html#spring-core 依赖： 理论上我们Spring框架的四个核心都要引进来，但是maven会自动吧依赖包的依赖也给引进来，所以只需要引进来一个spring-context依赖就行。 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置文件： 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&lt;!-- 将创建的对象交给Spring容器，在整个文件声明我要什么对象。 class：java类的全限定名，他是通过全另类名，然后使用反射的技术进行创建的。 id：ID就是给这个对象在整个应用程序上下文中娶个名字以方便区分。 --&gt; &lt;bean class="com.llp.pojo.Girl" id="girl"&gt;&lt;/bean&gt;&lt;/beans&gt; java代码： 12345678910111213141516171819202122package com.llp.pojo;public class Girl &#123; private String name; private Integer age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 1234567891011121314151617package com.llp;import com.llp.pojo.Girl;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestSpring &#123; @Test public void mm() &#123; //获取上下文对象,Spring声明的修行都可以通过上下文对象进行获取。 ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml"); //通多队形获取girl Girl g = (Girl) ctx.getBean("girl"); System.out.println(g); &#125;&#125; 普通编写VSspring的方式​ 普通的获取对象的方式，所有对象之间的依赖关系都是在java代码里面维护的，但是很难维护。如果说有替换方案，但是替换又比较困难。 ​ 对象产生全部都是在配置文件当中完成的。其实我们想要分析关系，直接在配置文件当中就看出来了。 核心内容学习： IOC（inverse of control，控制反转）也叫DI（依赖注入） AOP（面向切面编程） IOC概念： ​ 控制反转：什么控制什么，谁反转了谁。 控制：创建对象，彼此关系的权利。 控制权在开发人员程序代码当中进行掌控，利用new的方式。 夺取控制权反转给Spring容器。 声明要什么。 spring来进行自己的控制。 改变了我们编程的方式。 我们可以有多context.xml文件，但是这些xml文件里面bean标签的id一定不要重复。 对于spring来说bean的类是单例模式。 值的注入方式值的注入有两种方式： 第一种，setter注入 ​ 对应字段要有setter方法才可以完成注入 ​ 通过property完成注入 1234&lt;bean class="com.llp.pojo.Girl" id="girl"&gt; &lt;property name="name" value="王菲"/&gt; &lt;property name="age" value="18"/&gt; &lt;/bean&gt; 如果没有对应的setter方法就会发生如下的抱错： 1Invalid property 'age' of bean class [com.llp.pojo.Girl]: Bean property 'age' is not writable or has an invalid setter method. 但是默认是用无参构造器完成对象创建的，如果没有默认的无参构造器，会报一下错误： 1No default constructor found; nested exception is java.lang.NoSuchMethodException 第二种方式，构造注入 1234&lt;bean class="com.llp.pojo.Dog" id="dog"&gt; &lt;constructor-arg name="name" value="旺财"/&gt;&lt;/bean&gt;&lt;!--除了name我们还可以使用index（优先使用后面的构造器），type(入参的数据类型)--&gt; 但是有一个前提，就是要有相应的构造器。 beans元素探讨属性探讨： abstract：bean无法被实例化 parent：指定他的符bean是谁，将会继承父bean的所有内容，通过id进行引导。 12345678&lt;bean class="com.llp.pojo.Girl" id="mygirl"&gt; &lt;property name="name" value="韩雪"/&gt; &lt;!--&lt;property name="age" value="28"/&gt;--&gt;&lt;/bean&gt;&lt;bean class="com.llp.pojo.Girl" parent="mygirl" id="mygirl3"&gt; &lt;property name="age" value="33"&gt;&lt;/property&gt;&lt;/bean&gt; destory-methord：指定这个bean最后销毁的时候一定执行的方法，适合执行清理型的工作，触发条件是bean确实是被销毁才会执行。 ​ 容器close会被触法。 ​ refresh也会被触发。 ​ 过时的destory也会被触发，只是已经不再推荐使用了。 1234// ((ClassPathXmlApplicationContext)ctx).close();// ((ClassPathXmlApplicationContext) ctx).stop();不会触发// ((ClassPathXmlApplicationContext) ctx).refresh();// ((ClassPathXmlApplicationContext) ctx).destroy(); 过时操作 inite-methord：指定bean的初始化方法，准备性工作。（比如要先连接数据库） name：为bean取个别名，可以通过它一样可以获取到这个类。但是它可以写多个。彼此分割可以用空格，逗号，分号等等。 scope：指定范围，默认值为singleton（单例，Spring上下文只有一个实例，注意不是整个应用程序），prototype（原型）。 lazy-init：延迟初始化。默认情况下，容器初始化的时候就会立马完成注入。true，初始化延迟（但是还是会注入，但是只是使用的时候才会注入。）。 直接初始化：应用程序启动会慢一些，但是内存消耗更大。当我们使用bean的时候会快一些。 延迟初始化：程序启动会快一些，内存消耗更小。使用bean会慢一些。 depend-on：依赖bean，如果某一个bean的使用严重依赖于另外一个bean的准备的话，那就可以配置。 关于在配置文件当中单独配置我们的别名通过alias标签完成即可。 对于非字面值可以描述的值的问题： 123456789&lt;bean class="com.llp.pojo.Dog" id="dog"&gt; &lt;property name="name" value="哮天犬"/&gt;&lt;/bean&gt;&lt;bean class="com.llp.pojo.Girl" id="NauntyGirl"&gt; &lt;property name="dog" ref="dog"/&gt;&lt;/bean&gt;&lt;!-- 主要是，有没有一个方法 --&gt; 我们一般通过ref来只想另外一个bean的id。 Spring文件当中的多个bean是可以相互引用的（被上下文扫描到）。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatisz配置文件详解]]></title>
    <url>%2F2019%2F03%2F26%2F%5Bobject%20Object%5D%2F</url>
    <content type="text"><![CDATA[​ 我们一般都会有一个关于mybatis的配置文件（资源文件夹当中），一般会是比如我再这里是以mybatis.cfg.xml来进行命名。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 结论：dataSource里面的字面值属性优先级&gt;&gt;&gt;外部的properties优先级&gt;&gt;&gt;properties子节点的属性优先级 --&gt; &lt;properties resource="jdbc.properties"&gt; &lt;property name="username" value="123"&gt;&lt;/property&gt; &lt;/properties&gt; &lt;settings&gt; &lt;!-- Globally enables or disables any caches configured in any mapper under this configuration --&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;!-- Sets the number of seconds the driver will wait for a response from the database --&gt; &lt;setting name="defaultStatementTimeout" value="5"/&gt; &lt;!-- Enables automatic mapping from classic database column names A_COLUMN to camel case classic Java property names aColumn --&gt; &lt;!-- 开启下划线风格转换为驼峰命名风格 数据库常常采用下划线， 而javabean采用的是驼峰， 不匹配的问题 --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; &lt;!-- Allows JDBC support for generated keys. A compatible driver is required. This setting forces generated keys to be used if set to true, as some drivers deny compatibility but still work --&gt; &lt;setting name="useGeneratedKeys" value="true"/&gt; &lt;setting name="logImpl" value="LOG4J"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!--类型的别名--&gt; &lt;!--com.llp.pojo.xxx xxx--&gt; &lt;!--注册一个简写的别名，可以在其他的mapper文件当中被引用--&gt; &lt;typeAlias type="com.llp.pojo.Girl" alias="girl"&gt;&lt;/typeAlias&gt; &lt;!--直接注册整个包名，默认规则简写类名--&gt; &lt;package name="com.llp.pojo"/&gt; &lt;/typeAliases&gt; &lt;environments default="dev"&gt; &lt;environment id="dev"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="UNPOOLED"&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;!--可以直接通过$&#123;&#125;表达式来引用property里面规定的属性值--&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!--第一种方式：通过类路径来引入XML文件--&gt; &lt;!--不要写.要写斜杠--&gt; &lt;!--&lt;mapper resource="com/llp/mapper/GirlMapper.xml"&gt;&lt;/mapper&gt;--&gt; &lt;!--第二种：通过URL 协议：地址的方式引入--&gt; &lt;!--&lt;mapper url="file:///E:\program\javaprogram\mybatis002\src\main\resources\com\llp\mapper\GirlMapper.xml"/&gt;--&gt; &lt;!--第三种：通过接口的全限定名来引入，必须保持我们的接口和xml在同包之下--&gt; &lt;!--&lt;mapper class="com.llp.mapper.GirlMapper"/&gt;--&gt; &lt;!--第四种方式:引入一个包的方式，以后只要是新建的mapper都不必再重新引入--&gt; &lt;package name="com.llp.mapper"/&gt; &lt;/mappers&gt; &lt;!-- Continue editing here --&gt;&lt;/configuration&gt; properties(属性)​ 有一个properties标签，其中创建property标签中的name属性和value属性，方便后面environment的dataSource中property进行引用。 ​ 但是我们既可以创建标签的形式来实现对property的配置，也可以引用Java传统建立*.properties文件的方式实现。有一个resource属性来填写外部的资源文件jdbc.properties。 123&lt;properties resource="jdbc.properties"&gt; &lt;property name="username" value="123"&gt;&lt;/property&gt;&lt;/properties&gt; ​ 但是值得我们关注的是，dataSource里面的字面值属性优先级&gt;&gt;&gt;外部的properties优先级&gt;&gt;&gt;properties子节点的属性优先级。 settings（设置）​ settings设置在全局配置文件中比较重要。 ​ 一个相对完整的settings如下，这是官方推荐内容： 1234567891011121314151617&lt;settings&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="multipleResultSetsEnabled" value="true"/&gt; &lt;setting name="useColumnLabel" value="true"/&gt; &lt;setting name="useGeneratedKeys" value="false"/&gt; &lt;setting name="autoMappingBehavior" value="PARTIAL"/&gt; &lt;setting name="autoMappingUnknownColumnBehavior" value="WARNING"/&gt; &lt;setting name="defaultExecutorType" value="SIMPLE"/&gt; &lt;setting name="defaultStatementTimeout" value="25"/&gt; &lt;setting name="defaultFetchSize" value="100"/&gt; &lt;setting name="safeRowBoundsEnabled" value="false"/&gt; &lt;setting name="mapUnderscoreToCamelCase" value="false"/&gt; &lt;setting name="localCacheScope" value="SESSION"/&gt; &lt;setting name="jdbcTypeForNull" value="OTHER"/&gt; &lt;setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/&gt;&lt;/settings&gt; 但是其中最最需要注意的是以下两个： 关于二级缓存的配置 1&lt;setting name="cacheEnabled" value="true"/&gt; 关于开启下划线风格转换为驼峰命名风格的功能 1&lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; typeAliases(类名）​ 类型别名是为 Java 类型设置一个短的名字。 它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。简单的来讲就是为Java类型取别名的一个标签，，默认为类名的小写。 ​ 子标签一般是typeAlias或者package。package设置的是为当前包包括子包下面的所有类，这就有个问题，如果当前包和子包下面的类名一样，那么就会起冲突，这样样的解决方式就是使用注解方式，@Alias(“user”)，使用的前提是得引入mybatis库文件并设置环境变量： 123456789&lt;typeAliases&gt; &lt;!--类型的别名--&gt; &lt;!--com.llp.pojo.xxx xxx--&gt; &lt;!--注册一个简写的别名，可以在其他的mapper文件当中被引用--&gt; &lt;typeAlias type="com.llp.pojo.Girl" alias="girl"&gt;&lt;/typeAlias&gt; &lt;!--直接注册整个包名，默认规则简写类名--&gt; &lt;package name="com.llp.pojo"/&gt;&lt;/typeAliases&gt; environments(环境)environments设置开发环境，可以配置多个环境，由单个environment配置环境，在environment中必须有transactionManager和dataSource标签才算完整。 ​ environment的id为设置环境的唯一id标签，由environments中的default设置使用哪一种环境。 ​ transactionManager中type有两种:JDBC，代表使用jdbc的方式进行事物的提交和回滚，MANAGED代表使用j2ee的方式进行提交和回滚。 ​ dataSource为数据源，type为数据源类型：UNPOOLED|POOLED|JNDI，UNPOOLED： UNPOOLED：该数据源的实现只是在每次请求时打开和关闭连接。虽然速度有点慢，但对于不需要立即可用连接性能的简单应用程序来说，这是一个不错的选择。在这个性能区域中，不同的数据库也有所不同，因此对于某些数据库来说，池和这个配置可能不太重要。 POOLED： 数据源池JDBC连接对象的实现，以避免创建新连接实例所需的初始连接和身份验证时间。这是并发web应用程序实现最快响应的流行方法。 JNDI：该数据源的实现是为了与容器(如EJB或应用程序服务器)一起使用，这些容器可以集中配置数据源或外部，并在JNDI上下文中引用它。 123456789101112&lt;environments default="dev"&gt; &lt;environment id="dev"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="UNPOOLED"&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;!--可以直接通过$&#123;&#125;表达式来引用property里面规定的属性值--&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; databaseIdProvider(数据库厂商标识)​ MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 databaseId 属性。 dataBaseIdProvider是为全局设置多个数据源，可以设置多个数据库，如mysql，oracle，sql server等数据库，type=”DB_VENDOR”就是得到数据库厂商表示来执行不同的sql。 12345&lt;databaseIdProvider type="DB_VENDOR"&gt; &lt;property name="MySQL" value="mysql"&gt;&lt;/property&gt; &lt;property name="Oracle" value="oracle"&gt;&lt;/property&gt; &lt;property name="SQL Server" value="sql server"&gt;&lt;/property&gt;&lt;/databaseIdProvider&gt; ​ 使用方法在sql映射文件mapper中设置，在查询标签中设是databaseId=”oracle”，设置数据库执行的sql语句。 12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.example.mybatis.dao.UserMapper"&gt; &lt;select id="findUserById" parameterType="int" resultType="com.example.mybatis.entity.User" databaseId="oracle"&gt; select id, username, sex from t_user where id = #&#123;id&#125; &lt;/select&gt; &lt;select id="findUserById" parameterType="int" resultType="com.example.mybatis.entity.User" databaseId="mysql"&gt; select id, username, sex from t_user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; Mapper(映射器)​ 映射器的功能就是告诉 MyBatis 到哪里去找映射文件。 你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。 123456789101112&lt;mappers&gt; &lt;!--第一种方式：通过类路径来引入XML文件--&gt; &lt;!--不要写.要写斜杠--&gt; &lt;mapper resource="com/llp/mapper/GirlMapper.xml"&gt;&lt;/mapper&gt; &lt;!--第二种：通过URL 协议：地址的方式引入--&gt; &lt;mapper url="file:///E:\program\javaprogram\mybatis002\src\main\resources\com\llp\mapper\GirlMapper.xml"/&gt; &lt;!--第三种：通过接口的全限定名来引入，必须保持我们的接口和xml在同包之下--&gt; &lt;mapper class="com.llp.mapper.GirlMapper"/&gt; &lt;!--第四种方式:引入一个包的方式，以后只要是新建的mapper都不必再重新引入--&gt; &lt;package name="com.llp.mapper"/&gt;&lt;/mappers&gt;]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
</search>
