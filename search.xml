<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[my blog]]></title>
    <url>%2F2019%2F04%2F01%2Fmy-blog%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mybatis简单工作流程]]></title>
    <url>%2F2019%2F03%2F26%2F%5Bobject%20Object%5D%2F</url>
    <content type="text"><![CDATA[Mybatis简单工作流程SqlSessionFactory​ SqlSessionFactory是MyBatis的关键对象,它是个单个数据库映射关系经过编译后的内存镜像。 ​ 每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。同时SqlSessionFactory也是线程安全的,SqlSessionFactory一旦被创建,应该在应用执行期间都存在.在应用运行期间不要重复创建多次,建议使用单例模式.SqlSessionFactory是创建SqlSession的工厂。 SqlSession​ SqlSession是MyBatis的关键对象,是执行持久化操作的独享,类似于JDBC中的Connection。它是应用程序与持久层之间执行交互操作的一个单线程对象,也是MyBatis执行持久化操作的关键对象。它的底层封装了JDBC连接,可以用SqlSession实例来直接执行被映射的SQL语句。每个线程都应该有它自己的SqlSession实例.SqlSession的实例不能被共享，同时SqlSession也是线程不安全的，绝对不能讲SqlSeesion实例的引用放在一个类的静态字段甚至是实例字段中。也绝不能将SqlSession实例的引用放在任何类型的管理范围中,比如Servlet当中的HttpSession对象中。使用完SqlSeesion之后关闭Session很重要,应该确保使用finally块来关闭它。 操作方式​ 核心虽然是 SqlSessionFactory但是我们真正要操作的是SqlSession。我们一般将产生SqlSession实例的过程封装在一个工具包（util）当中。这里我的类名是MybatisUtil： 123456789101112131415161718192021222324252627282930313233343536package com.llp.util;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MybatisUtil &#123; private static SqlSessionFactory sqlSessionFactory; static&#123;//通过静态代码块初始化静态变量SqlSessionFactory String resource = "mybatis.cfg.xml"; InputStream in = null ; try&#123; in = Resources.getResourceAsStream(resource);//获取文件资源信息 sqlSessionFactory = new SqlSessionFactoryBuilder().build(in);//获得 SqlSessionFactory对象 &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if(in != null) &#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static SqlSession getSession() &#123;//其他包中调用该工具包构造SqlSession需要执行的方法 return sqlSessionFactory.openSession(); &#125;&#125; ​ 然后我们只需要调用MybatisUtil的getSession()方法即可。 特别强调的是SqlSession是单线程非安全的，所以只能每次打开之后都要关闭，并且每一次会话之后都要关闭（close）。]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatisz配置文件详解]]></title>
    <url>%2F2019%2F03%2F26%2F%5Bobject%20Object%5D%2F</url>
    <content type="text"><![CDATA[​ 我们一般都会有一个关于mybatis的配置文件（资源文件夹当中），一般会是比如我再这里是以mybatis.cfg.xml来进行命名。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 结论：dataSource里面的字面值属性优先级&gt;&gt;&gt;外部的properties优先级&gt;&gt;&gt;properties子节点的属性优先级 --&gt; &lt;properties resource="jdbc.properties"&gt; &lt;property name="username" value="123"&gt;&lt;/property&gt; &lt;/properties&gt; &lt;settings&gt; &lt;!-- Globally enables or disables any caches configured in any mapper under this configuration --&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;!-- Sets the number of seconds the driver will wait for a response from the database --&gt; &lt;setting name="defaultStatementTimeout" value="5"/&gt; &lt;!-- Enables automatic mapping from classic database column names A_COLUMN to camel case classic Java property names aColumn --&gt; &lt;!-- 开启下划线风格转换为驼峰命名风格 数据库常常采用下划线， 而javabean采用的是驼峰， 不匹配的问题 --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; &lt;!-- Allows JDBC support for generated keys. A compatible driver is required. This setting forces generated keys to be used if set to true, as some drivers deny compatibility but still work --&gt; &lt;setting name="useGeneratedKeys" value="true"/&gt; &lt;setting name="logImpl" value="LOG4J"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!--类型的别名--&gt; &lt;!--com.llp.pojo.xxx xxx--&gt; &lt;!--注册一个简写的别名，可以在其他的mapper文件当中被引用--&gt; &lt;typeAlias type="com.llp.pojo.Girl" alias="girl"&gt;&lt;/typeAlias&gt; &lt;!--直接注册整个包名，默认规则简写类名--&gt; &lt;package name="com.llp.pojo"/&gt; &lt;/typeAliases&gt; &lt;environments default="dev"&gt; &lt;environment id="dev"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="UNPOOLED"&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;!--可以直接通过$&#123;&#125;表达式来引用property里面规定的属性值--&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!--第一种方式：通过类路径来引入XML文件--&gt; &lt;!--不要写.要写斜杠--&gt; &lt;!--&lt;mapper resource="com/llp/mapper/GirlMapper.xml"&gt;&lt;/mapper&gt;--&gt; &lt;!--第二种：通过URL 协议：地址的方式引入--&gt; &lt;!--&lt;mapper url="file:///E:\program\javaprogram\mybatis002\src\main\resources\com\llp\mapper\GirlMapper.xml"/&gt;--&gt; &lt;!--第三种：通过接口的全限定名来引入，必须保持我们的接口和xml在同包之下--&gt; &lt;!--&lt;mapper class="com.llp.mapper.GirlMapper"/&gt;--&gt; &lt;!--第四种方式:引入一个包的方式，以后只要是新建的mapper都不必再重新引入--&gt; &lt;package name="com.llp.mapper"/&gt; &lt;/mappers&gt; &lt;!-- Continue editing here --&gt;&lt;/configuration&gt; properties(属性)​ 有一个properties标签，其中创建property标签中的name属性和value属性，方便后面environment的dataSource中property进行引用。 ​ 但是我们既可以创建标签的形式来实现对property的配置，也可以引用Java传统建立*.properties文件的方式实现。有一个resource属性来填写外部的资源文件jdbc.properties。 123&lt;properties resource="jdbc.properties"&gt; &lt;property name="username" value="123"&gt;&lt;/property&gt;&lt;/properties&gt; ​ 但是值得我们关注的是，dataSource里面的字面值属性优先级&gt;&gt;&gt;外部的properties优先级&gt;&gt;&gt;properties子节点的属性优先级。 settings（设置）​ settings设置在全局配置文件中比较重要。 ​ 一个相对完整的settings如下，这是官方推荐内容： 1234567891011121314151617&lt;settings&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="multipleResultSetsEnabled" value="true"/&gt; &lt;setting name="useColumnLabel" value="true"/&gt; &lt;setting name="useGeneratedKeys" value="false"/&gt; &lt;setting name="autoMappingBehavior" value="PARTIAL"/&gt; &lt;setting name="autoMappingUnknownColumnBehavior" value="WARNING"/&gt; &lt;setting name="defaultExecutorType" value="SIMPLE"/&gt; &lt;setting name="defaultStatementTimeout" value="25"/&gt; &lt;setting name="defaultFetchSize" value="100"/&gt; &lt;setting name="safeRowBoundsEnabled" value="false"/&gt; &lt;setting name="mapUnderscoreToCamelCase" value="false"/&gt; &lt;setting name="localCacheScope" value="SESSION"/&gt; &lt;setting name="jdbcTypeForNull" value="OTHER"/&gt; &lt;setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/&gt;&lt;/settings&gt; 但是其中最最需要注意的是以下两个： 关于二级缓存的配置 1&lt;setting name="cacheEnabled" value="true"/&gt; 关于开启下划线风格转换为驼峰命名风格的功能 1&lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; typeAliases(类名）​ 类型别名是为 Java 类型设置一个短的名字。 它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。简单的来讲就是为Java类型取别名的一个标签，，默认为类名的小写。 ​ 子标签一般是typeAlias或者package。package设置的是为当前包包括子包下面的所有类，这就有个问题，如果当前包和子包下面的类名一样，那么就会起冲突，这样样的解决方式就是使用注解方式，@Alias(“user”)，使用的前提是得引入mybatis库文件并设置环境变量： 123456789&lt;typeAliases&gt; &lt;!--类型的别名--&gt; &lt;!--com.llp.pojo.xxx xxx--&gt; &lt;!--注册一个简写的别名，可以在其他的mapper文件当中被引用--&gt; &lt;typeAlias type="com.llp.pojo.Girl" alias="girl"&gt;&lt;/typeAlias&gt; &lt;!--直接注册整个包名，默认规则简写类名--&gt; &lt;package name="com.llp.pojo"/&gt;&lt;/typeAliases&gt; environments(环境)environments设置开发环境，可以配置多个环境，由单个environment配置环境，在environment中必须有transactionManager和dataSource标签才算完整。 ​ environment的id为设置环境的唯一id标签，由environments中的default设置使用哪一种环境。 ​ transactionManager中type有两种:JDBC，代表使用jdbc的方式进行事物的提交和回滚，MANAGED代表使用j2ee的方式进行提交和回滚。 ​ dataSource为数据源，type为数据源类型：UNPOOLED|POOLED|JNDI，UNPOOLED： UNPOOLED：该数据源的实现只是在每次请求时打开和关闭连接。虽然速度有点慢，但对于不需要立即可用连接性能的简单应用程序来说，这是一个不错的选择。在这个性能区域中，不同的数据库也有所不同，因此对于某些数据库来说，池和这个配置可能不太重要。 POOLED： 数据源池JDBC连接对象的实现，以避免创建新连接实例所需的初始连接和身份验证时间。这是并发web应用程序实现最快响应的流行方法。 JNDI：该数据源的实现是为了与容器(如EJB或应用程序服务器)一起使用，这些容器可以集中配置数据源或外部，并在JNDI上下文中引用它。 123456789101112&lt;environments default="dev"&gt; &lt;environment id="dev"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="UNPOOLED"&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;!--可以直接通过$&#123;&#125;表达式来引用property里面规定的属性值--&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; databaseIdProvider(数据库厂商标识)​ MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 databaseId 属性。 dataBaseIdProvider是为全局设置多个数据源，可以设置多个数据库，如mysql，oracle，sql server等数据库，type=”DB_VENDOR”就是得到数据库厂商表示来执行不同的sql。 12345&lt;databaseIdProvider type="DB_VENDOR"&gt; &lt;property name="MySQL" value="mysql"&gt;&lt;/property&gt; &lt;property name="Oracle" value="oracle"&gt;&lt;/property&gt; &lt;property name="SQL Server" value="sql server"&gt;&lt;/property&gt;&lt;/databaseIdProvider&gt; ​ 使用方法在sql映射文件mapper中设置，在查询标签中设是databaseId=”oracle”，设置数据库执行的sql语句。 12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.example.mybatis.dao.UserMapper"&gt; &lt;select id="findUserById" parameterType="int" resultType="com.example.mybatis.entity.User" databaseId="oracle"&gt; select id, username, sex from t_user where id = #&#123;id&#125; &lt;/select&gt; &lt;select id="findUserById" parameterType="int" resultType="com.example.mybatis.entity.User" databaseId="mysql"&gt; select id, username, sex from t_user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; Mapper(映射器)​ 映射器的功能就是告诉 MyBatis 到哪里去找映射文件。 你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。 123456789101112&lt;mappers&gt; &lt;!--第一种方式：通过类路径来引入XML文件--&gt; &lt;!--不要写.要写斜杠--&gt; &lt;mapper resource="com/llp/mapper/GirlMapper.xml"&gt;&lt;/mapper&gt; &lt;!--第二种：通过URL 协议：地址的方式引入--&gt; &lt;mapper url="file:///E:\program\javaprogram\mybatis002\src\main\resources\com\llp\mapper\GirlMapper.xml"/&gt; &lt;!--第三种：通过接口的全限定名来引入，必须保持我们的接口和xml在同包之下--&gt; &lt;mapper class="com.llp.mapper.GirlMapper"/&gt; &lt;!--第四种方式:引入一个包的方式，以后只要是新建的mapper都不必再重新引入--&gt; &lt;package name="com.llp.mapper"/&gt;&lt;/mappers&gt;]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
</search>
